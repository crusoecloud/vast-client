/*
VAST API Swagger Schema

VAST Management API definition

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ActivedirectoryAPIService ActivedirectoryAPI service
type ActivedirectoryAPIService service

type ActivedirectoryAPIActiveDirectoryCreateRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
	activeDirectoryCreateParams *ActiveDirectoryCreateRequest
}

func (r ActivedirectoryAPIActiveDirectoryCreateRequest) ActiveDirectoryCreateParams(activeDirectoryCreateParams ActiveDirectoryCreateRequest) ActivedirectoryAPIActiveDirectoryCreateRequest {
	r.activeDirectoryCreateParams = &activeDirectoryCreateParams
	return r
}

func (r ActivedirectoryAPIActiveDirectoryCreateRequest) Execute() (*ActiveDirectory, *http.Response, error) {
	return r.ApiService.ActiveDirectoryCreateExecute(r)
}

/*
ActiveDirectoryCreate Create Active Directory Configuration

This endpoint creates an Active Directory configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivedirectoryAPIActiveDirectoryCreateRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryCreate(ctx context.Context) ActivedirectoryAPIActiveDirectoryCreateRequest {
	return ActivedirectoryAPIActiveDirectoryCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActiveDirectory
func (a *ActivedirectoryAPIService) ActiveDirectoryCreateExecute(r ActivedirectoryAPIActiveDirectoryCreateRequest) (*ActiveDirectory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveDirectory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.activeDirectoryCreateParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivedirectoryAPIActiveDirectoryCurrentGcRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
	id int32
}

func (r ActivedirectoryAPIActiveDirectoryCurrentGcRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActiveDirectoryCurrentGcExecute(r)
}

/*
ActiveDirectoryCurrentGc Get current AD GC

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id AD ID
 @return ActivedirectoryAPIActiveDirectoryCurrentGcRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryCurrentGc(ctx context.Context, id int32) ActivedirectoryAPIActiveDirectoryCurrentGcRequest {
	return ActivedirectoryAPIActiveDirectoryCurrentGcRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActivedirectoryAPIService) ActiveDirectoryCurrentGcExecute(r ActivedirectoryAPIActiveDirectoryCurrentGcRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryCurrentGc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/{id}/current_gc/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivedirectoryAPIActiveDirectoryDcsRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
	id int32
	state *string
	isClosest *string
	uri *string
	port *string
}

func (r ActivedirectoryAPIActiveDirectoryDcsRequest) State(state string) ActivedirectoryAPIActiveDirectoryDcsRequest {
	r.state = &state
	return r
}

func (r ActivedirectoryAPIActiveDirectoryDcsRequest) IsClosest(isClosest string) ActivedirectoryAPIActiveDirectoryDcsRequest {
	r.isClosest = &isClosest
	return r
}

func (r ActivedirectoryAPIActiveDirectoryDcsRequest) Uri(uri string) ActivedirectoryAPIActiveDirectoryDcsRequest {
	r.uri = &uri
	return r
}

func (r ActivedirectoryAPIActiveDirectoryDcsRequest) Port(port string) ActivedirectoryAPIActiveDirectoryDcsRequest {
	r.port = &port
	return r
}

func (r ActivedirectoryAPIActiveDirectoryDcsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActiveDirectoryDcsExecute(r)
}

/*
ActiveDirectoryDcs Get AD DCs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id AD ID
 @return ActivedirectoryAPIActiveDirectoryDcsRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryDcs(ctx context.Context, id int32) ActivedirectoryAPIActiveDirectoryDcsRequest {
	return ActivedirectoryAPIActiveDirectoryDcsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActivedirectoryAPIService) ActiveDirectoryDcsExecute(r ActivedirectoryAPIActiveDirectoryDcsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryDcs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/{id}/dcs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}

	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.isClosest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_closest", r.isClosest, "")
	}
	if r.uri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uri", r.uri, "")
	}
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivedirectoryAPIActiveDirectoryDeleteRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
	id string
	activeDirectoryDeleteParams *ActiveDirectoryDeleteRequest
}

func (r ActivedirectoryAPIActiveDirectoryDeleteRequest) ActiveDirectoryDeleteParams(activeDirectoryDeleteParams ActiveDirectoryDeleteRequest) ActivedirectoryAPIActiveDirectoryDeleteRequest {
	r.activeDirectoryDeleteParams = &activeDirectoryDeleteParams
	return r
}

func (r ActivedirectoryAPIActiveDirectoryDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActiveDirectoryDeleteExecute(r)
}

/*
ActiveDirectoryDelete Delete Active Directory configuration

This endpoint deletes an Active Directory configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Active Directory ID
 @return ActivedirectoryAPIActiveDirectoryDeleteRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryDelete(ctx context.Context, id string) ActivedirectoryAPIActiveDirectoryDeleteRequest {
	return ActivedirectoryAPIActiveDirectoryDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ActivedirectoryAPIService) ActiveDirectoryDeleteExecute(r ActivedirectoryAPIActiveDirectoryDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.activeDirectoryDeleteParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ActivedirectoryAPIActiveDirectoryDomainsRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
	id int32
	baseDn *string
	fqdn *string
	sid *string
}

func (r ActivedirectoryAPIActiveDirectoryDomainsRequest) BaseDn(baseDn string) ActivedirectoryAPIActiveDirectoryDomainsRequest {
	r.baseDn = &baseDn
	return r
}

func (r ActivedirectoryAPIActiveDirectoryDomainsRequest) Fqdn(fqdn string) ActivedirectoryAPIActiveDirectoryDomainsRequest {
	r.fqdn = &fqdn
	return r
}

func (r ActivedirectoryAPIActiveDirectoryDomainsRequest) Sid(sid string) ActivedirectoryAPIActiveDirectoryDomainsRequest {
	r.sid = &sid
	return r
}

func (r ActivedirectoryAPIActiveDirectoryDomainsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActiveDirectoryDomainsExecute(r)
}

/*
ActiveDirectoryDomains Get AD domains

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id AD ID
 @return ActivedirectoryAPIActiveDirectoryDomainsRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryDomains(ctx context.Context, id int32) ActivedirectoryAPIActiveDirectoryDomainsRequest {
	return ActivedirectoryAPIActiveDirectoryDomainsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActivedirectoryAPIService) ActiveDirectoryDomainsExecute(r ActivedirectoryAPIActiveDirectoryDomainsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryDomains")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/{id}/domains/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}

	if r.baseDn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_dn", r.baseDn, "")
	}
	if r.fqdn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fqdn", r.fqdn, "")
	}
	if r.sid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sid", r.sid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivedirectoryAPIActiveDirectoryGcsRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
	id int32
	state *string
	isClosest *string
	uri *string
	port *string
}

func (r ActivedirectoryAPIActiveDirectoryGcsRequest) State(state string) ActivedirectoryAPIActiveDirectoryGcsRequest {
	r.state = &state
	return r
}

func (r ActivedirectoryAPIActiveDirectoryGcsRequest) IsClosest(isClosest string) ActivedirectoryAPIActiveDirectoryGcsRequest {
	r.isClosest = &isClosest
	return r
}

func (r ActivedirectoryAPIActiveDirectoryGcsRequest) Uri(uri string) ActivedirectoryAPIActiveDirectoryGcsRequest {
	r.uri = &uri
	return r
}

func (r ActivedirectoryAPIActiveDirectoryGcsRequest) Port(port string) ActivedirectoryAPIActiveDirectoryGcsRequest {
	r.port = &port
	return r
}

func (r ActivedirectoryAPIActiveDirectoryGcsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ActiveDirectoryGcsExecute(r)
}

/*
ActiveDirectoryGcs Get AD GCs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id AD ID
 @return ActivedirectoryAPIActiveDirectoryGcsRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryGcs(ctx context.Context, id int32) ActivedirectoryAPIActiveDirectoryGcsRequest {
	return ActivedirectoryAPIActiveDirectoryGcsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ActivedirectoryAPIService) ActiveDirectoryGcsExecute(r ActivedirectoryAPIActiveDirectoryGcsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryGcs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/{id}/gcs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}

	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.isClosest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_closest", r.isClosest, "")
	}
	if r.uri != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uri", r.uri, "")
	}
	if r.port != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port", r.port, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivedirectoryAPIActiveDirectoryIsOperationHealthyRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
	id int32
	operation *string
	aDIsOperationHealthyParams *ActiveDirectoryIsOperationHealthyRequest
}

func (r ActivedirectoryAPIActiveDirectoryIsOperationHealthyRequest) Operation(operation string) ActivedirectoryAPIActiveDirectoryIsOperationHealthyRequest {
	r.operation = &operation
	return r
}

func (r ActivedirectoryAPIActiveDirectoryIsOperationHealthyRequest) ADIsOperationHealthyParams(aDIsOperationHealthyParams ActiveDirectoryIsOperationHealthyRequest) ActivedirectoryAPIActiveDirectoryIsOperationHealthyRequest {
	r.aDIsOperationHealthyParams = &aDIsOperationHealthyParams
	return r
}

func (r ActivedirectoryAPIActiveDirectoryIsOperationHealthyRequest) Execute() (*Warnings, *http.Response, error) {
	return r.ApiService.ActiveDirectoryIsOperationHealthyExecute(r)
}

/*
ActiveDirectoryIsOperationHealthy Check whether an operation may be successfully performed

Returns warnings about the future state if operation is performed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id AD ID
 @return ActivedirectoryAPIActiveDirectoryIsOperationHealthyRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryIsOperationHealthy(ctx context.Context, id int32) ActivedirectoryAPIActiveDirectoryIsOperationHealthyRequest {
	return ActivedirectoryAPIActiveDirectoryIsOperationHealthyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Warnings
func (a *ActivedirectoryAPIService) ActiveDirectoryIsOperationHealthyExecute(r ActivedirectoryAPIActiveDirectoryIsOperationHealthyRequest) (*Warnings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Warnings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryIsOperationHealthy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/{id}/is_operation_healthy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}

	if r.operation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operation", r.operation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aDIsOperationHealthyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivedirectoryAPIActiveDirectoryListRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
}

func (r ActivedirectoryAPIActiveDirectoryListRequest) Execute() ([]ActiveDirectory, *http.Response, error) {
	return r.ApiService.ActiveDirectoryListExecute(r)
}

/*
ActiveDirectoryList List Active Directory Configurations

This endpoint lists all Active Directory configurations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ActivedirectoryAPIActiveDirectoryListRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryList(ctx context.Context) ActivedirectoryAPIActiveDirectoryListRequest {
	return ActivedirectoryAPIActiveDirectoryListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ActiveDirectory
func (a *ActivedirectoryAPIService) ActiveDirectoryListExecute(r ActivedirectoryAPIActiveDirectoryListRequest) ([]ActiveDirectory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ActiveDirectory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivedirectoryAPIActiveDirectoryPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
	id string
	activeDirectoryModifyParams *ActiveDirectoryPartialUpdateRequest
}

func (r ActivedirectoryAPIActiveDirectoryPartialUpdateRequest) ActiveDirectoryModifyParams(activeDirectoryModifyParams ActiveDirectoryPartialUpdateRequest) ActivedirectoryAPIActiveDirectoryPartialUpdateRequest {
	r.activeDirectoryModifyParams = &activeDirectoryModifyParams
	return r
}

func (r ActivedirectoryAPIActiveDirectoryPartialUpdateRequest) Execute() (*AsyncTaskInResponse, *http.Response, error) {
	return r.ApiService.ActiveDirectoryPartialUpdateExecute(r)
}

/*
ActiveDirectoryPartialUpdate Join or Leave Active Directory

This endpoint joins or leaves an Active Directory server.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the Active Directory configuration for the AD server to join
 @return ActivedirectoryAPIActiveDirectoryPartialUpdateRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryPartialUpdate(ctx context.Context, id string) ActivedirectoryAPIActiveDirectoryPartialUpdateRequest {
	return ActivedirectoryAPIActiveDirectoryPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AsyncTaskInResponse
func (a *ActivedirectoryAPIService) ActiveDirectoryPartialUpdateExecute(r ActivedirectoryAPIActiveDirectoryPartialUpdateRequest) (*AsyncTaskInResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncTaskInResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.activeDirectoryModifyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivedirectoryAPIActiveDirectoryReadRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
	id string
}

func (r ActivedirectoryAPIActiveDirectoryReadRequest) Execute() (*ActiveDirectory, *http.Response, error) {
	return r.ApiService.ActiveDirectoryReadExecute(r)
}

/*
ActiveDirectoryRead Return Active Directory Configuration Details

This endpoint returns details of a specified Active Directory configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Active Directory ID
 @return ActivedirectoryAPIActiveDirectoryReadRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryRead(ctx context.Context, id string) ActivedirectoryAPIActiveDirectoryReadRequest {
	return ActivedirectoryAPIActiveDirectoryReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActiveDirectory
func (a *ActivedirectoryAPIService) ActiveDirectoryReadExecute(r ActivedirectoryAPIActiveDirectoryReadRequest) (*ActiveDirectory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveDirectory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ActivedirectoryAPIActiveDirectoryRefreshRequest struct {
	ctx context.Context
	ApiService *ActivedirectoryAPIService
	id string
}

func (r ActivedirectoryAPIActiveDirectoryRefreshRequest) Execute() (*http.Response, error) {
	return r.ApiService.ActiveDirectoryRefreshExecute(r)
}

/*
ActiveDirectoryRefresh Refresh AD

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id AD ID
 @return ActivedirectoryAPIActiveDirectoryRefreshRequest
*/
func (a *ActivedirectoryAPIService) ActiveDirectoryRefresh(ctx context.Context, id string) ActivedirectoryAPIActiveDirectoryRefreshRequest {
	return ActivedirectoryAPIActiveDirectoryRefreshRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ActivedirectoryAPIService) ActiveDirectoryRefreshExecute(r ActivedirectoryAPIActiveDirectoryRefreshRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActivedirectoryAPIService.ActiveDirectoryRefresh")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activedirectory/{id}/refresh/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
