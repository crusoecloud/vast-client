/*
VAST API Swagger Schema

VAST Management API definition

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ProtectedpathsAPIService ProtectedpathsAPI service
type ProtectedpathsAPIService service

type ProtectedpathsAPIProtectedpathsAddStreamRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
	protectedPathAddStreamParams *ProtectedpathsAddStreamRequest
}

func (r ProtectedpathsAPIProtectedpathsAddStreamRequest) ProtectedPathAddStreamParams(protectedPathAddStreamParams ProtectedpathsAddStreamRequest) ProtectedpathsAPIProtectedpathsAddStreamRequest {
	r.protectedPathAddStreamParams = &protectedPathAddStreamParams
	return r
}

func (r ProtectedpathsAPIProtectedpathsAddStreamRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProtectedpathsAddStreamExecute(r)
}

/*
ProtectedpathsAddStream Add a Replication Stream to a group connected to this Protected Path

This endpoint adds Replication Stream to a group connected to this Protected Path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsAddStreamRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsAddStream(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsAddStreamRequest {
	return ProtectedpathsAPIProtectedpathsAddStreamRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProtectedpathsAPIService) ProtectedpathsAddStreamExecute(r ProtectedpathsAPIProtectedpathsAddStreamRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsAddStream")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/add_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectedPathAddStreamParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsCommitRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
	protectedPathCommitParams *map[string]interface{}
}

func (r ProtectedpathsAPIProtectedpathsCommitRequest) ProtectedPathCommitParams(protectedPathCommitParams map[string]interface{}) ProtectedpathsAPIProtectedpathsCommitRequest {
	r.protectedPathCommitParams = &protectedPathCommitParams
	return r
}

func (r ProtectedpathsAPIProtectedpathsCommitRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProtectedpathsCommitExecute(r)
}

/*
ProtectedpathsCommit Commits snapshot restore result to protected path.

This endpoint commits snapshot restore result to protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsCommitRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsCommit(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsCommitRequest {
	return ProtectedpathsAPIProtectedpathsCommitRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProtectedpathsAPIService) ProtectedpathsCommitExecute(r ProtectedpathsAPIProtectedpathsCommitRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsCommit")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/commit"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectedPathCommitParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsCreateRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	protectedPathCreateParams *ProtectedpathsCreateRequest
}

func (r ProtectedpathsAPIProtectedpathsCreateRequest) ProtectedPathCreateParams(protectedPathCreateParams ProtectedpathsCreateRequest) ProtectedpathsAPIProtectedpathsCreateRequest {
	r.protectedPathCreateParams = &protectedPathCreateParams
	return r
}

func (r ProtectedpathsAPIProtectedpathsCreateRequest) Execute() (*ProtectedPath, *http.Response, error) {
	return r.ApiService.ProtectedpathsCreateExecute(r)
}

/*
ProtectedpathsCreate Create a Protected Path

This endpoint creates a protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProtectedpathsAPIProtectedpathsCreateRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsCreate(ctx context.Context) ProtectedpathsAPIProtectedpathsCreateRequest {
	return ProtectedpathsAPIProtectedpathsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProtectedPath
func (a *ProtectedpathsAPIService) ProtectedpathsCreateExecute(r ProtectedpathsAPIProtectedpathsCreateRequest) (*ProtectedPath, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectedPath
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectedPathCreateParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsDeleteRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
}

func (r ProtectedpathsAPIProtectedpathsDeleteRequest) Execute() (*AsyncTaskInResponse, *http.Response, error) {
	return r.ApiService.ProtectedpathsDeleteExecute(r)
}

/*
ProtectedpathsDelete Delete a Protected Path

This endpoint deletes a protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsDeleteRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsDelete(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsDeleteRequest {
	return ProtectedpathsAPIProtectedpathsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AsyncTaskInResponse
func (a *ProtectedpathsAPIService) ProtectedpathsDeleteExecute(r ProtectedpathsAPIProtectedpathsDeleteRequest) (*AsyncTaskInResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncTaskInResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsForceFailoverRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
}

func (r ProtectedpathsAPIProtectedpathsForceFailoverRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProtectedpathsForceFailoverExecute(r)
}

/*
ProtectedpathsForceFailover Force failover protected path

This endpoint performs force fail-over on protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsForceFailoverRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsForceFailover(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsForceFailoverRequest {
	return ProtectedpathsAPIProtectedpathsForceFailoverRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProtectedpathsAPIService) ProtectedpathsForceFailoverExecute(r ProtectedpathsAPIProtectedpathsForceFailoverRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsForceFailover")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/force_failover"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsListRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	page *int32
	pageSize *int32
	state *string
	role *string
	sourceDir *string
	replicationPolicyName *string
	name *string
	enabled *string
}

func (r ProtectedpathsAPIProtectedpathsListRequest) Page(page int32) ProtectedpathsAPIProtectedpathsListRequest {
	r.page = &page
	return r
}

func (r ProtectedpathsAPIProtectedpathsListRequest) PageSize(pageSize int32) ProtectedpathsAPIProtectedpathsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ProtectedpathsAPIProtectedpathsListRequest) State(state string) ProtectedpathsAPIProtectedpathsListRequest {
	r.state = &state
	return r
}

func (r ProtectedpathsAPIProtectedpathsListRequest) Role(role string) ProtectedpathsAPIProtectedpathsListRequest {
	r.role = &role
	return r
}

func (r ProtectedpathsAPIProtectedpathsListRequest) SourceDir(sourceDir string) ProtectedpathsAPIProtectedpathsListRequest {
	r.sourceDir = &sourceDir
	return r
}

func (r ProtectedpathsAPIProtectedpathsListRequest) ReplicationPolicyName(replicationPolicyName string) ProtectedpathsAPIProtectedpathsListRequest {
	r.replicationPolicyName = &replicationPolicyName
	return r
}

func (r ProtectedpathsAPIProtectedpathsListRequest) Name(name string) ProtectedpathsAPIProtectedpathsListRequest {
	r.name = &name
	return r
}

// start/pause protected path
func (r ProtectedpathsAPIProtectedpathsListRequest) Enabled(enabled string) ProtectedpathsAPIProtectedpathsListRequest {
	r.enabled = &enabled
	return r
}

func (r ProtectedpathsAPIProtectedpathsListRequest) Execute() ([]ProtectedPath, *http.Response, error) {
	return r.ApiService.ProtectedpathsListExecute(r)
}

/*
ProtectedpathsList List Protected Paths

This endpoint lists protected paths.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProtectedpathsAPIProtectedpathsListRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsList(ctx context.Context) ProtectedpathsAPIProtectedpathsListRequest {
	return ProtectedpathsAPIProtectedpathsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ProtectedPath
func (a *ProtectedpathsAPIService) ProtectedpathsListExecute(r ProtectedpathsAPIProtectedpathsListRequest) ([]ProtectedPath, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ProtectedPath
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "")
	}
	if r.sourceDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source_dir", r.sourceDir, "")
	}
	if r.replicationPolicyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replication_policy__name", r.replicationPolicyName, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
	protectedPathModifyParams *ProtectedpathsPartialUpdateRequest
}

func (r ProtectedpathsAPIProtectedpathsPartialUpdateRequest) ProtectedPathModifyParams(protectedPathModifyParams ProtectedpathsPartialUpdateRequest) ProtectedpathsAPIProtectedpathsPartialUpdateRequest {
	r.protectedPathModifyParams = &protectedPathModifyParams
	return r
}

func (r ProtectedpathsAPIProtectedpathsPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProtectedpathsPartialUpdateExecute(r)
}

/*
ProtectedpathsPartialUpdate Modify a Protected Path

This endpoint modifies a protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsPartialUpdateRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsPartialUpdate(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsPartialUpdateRequest {
	return ProtectedpathsAPIProtectedpathsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProtectedpathsAPIService) ProtectedpathsPartialUpdateExecute(r ProtectedpathsAPIProtectedpathsPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectedPathModifyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsPauseRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
	protectedPathPauseParams *ProtectedpathsPauseRequest
}

func (r ProtectedpathsAPIProtectedpathsPauseRequest) ProtectedPathPauseParams(protectedPathPauseParams ProtectedpathsPauseRequest) ProtectedpathsAPIProtectedpathsPauseRequest {
	r.protectedPathPauseParams = &protectedPathPauseParams
	return r
}

func (r ProtectedpathsAPIProtectedpathsPauseRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProtectedpathsPauseExecute(r)
}

/*
ProtectedpathsPause Pause snapshot restore on protected path.

This endpoint pauses snapshot restore on protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsPauseRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsPause(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsPauseRequest {
	return ProtectedpathsAPIProtectedpathsPauseRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProtectedpathsAPIService) ProtectedpathsPauseExecute(r ProtectedpathsAPIProtectedpathsPauseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsPause")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectedPathPauseParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsReadRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
}

func (r ProtectedpathsAPIProtectedpathsReadRequest) Execute() (*ProtectedPath, *http.Response, error) {
	return r.ApiService.ProtectedpathsReadExecute(r)
}

/*
ProtectedpathsRead Return Details of a Protected Path

This endpoint returns details of a protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id index of protected path
 @return ProtectedpathsAPIProtectedpathsReadRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsRead(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsReadRequest {
	return ProtectedpathsAPIProtectedpathsReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProtectedPath
func (a *ProtectedpathsAPIService) ProtectedpathsReadExecute(r ProtectedpathsAPIProtectedpathsReadRequest) (*ProtectedPath, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectedPath
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsReattachStreamRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
	protectedPathReattachStreamParams *ProtectedpathsRemoveStreamRequest
}

func (r ProtectedpathsAPIProtectedpathsReattachStreamRequest) ProtectedPathReattachStreamParams(protectedPathReattachStreamParams ProtectedpathsRemoveStreamRequest) ProtectedpathsAPIProtectedpathsReattachStreamRequest {
	r.protectedPathReattachStreamParams = &protectedPathReattachStreamParams
	return r
}

func (r ProtectedpathsAPIProtectedpathsReattachStreamRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProtectedpathsReattachStreamExecute(r)
}

/*
ProtectedpathsReattachStream Reattach a Stream to this Protected Path

This endpoint re-attaches a replication stream to a current protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsReattachStreamRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsReattachStream(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsReattachStreamRequest {
	return ProtectedpathsAPIProtectedpathsReattachStreamRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProtectedpathsAPIService) ProtectedpathsReattachStreamExecute(r ProtectedpathsAPIProtectedpathsReattachStreamRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsReattachStream")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/reattach_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectedPathReattachStreamParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsRemoveStreamRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
	protectedPathRemoveStreamParams *ProtectedpathsRemoveStreamRequest
}

func (r ProtectedpathsAPIProtectedpathsRemoveStreamRequest) ProtectedPathRemoveStreamParams(protectedPathRemoveStreamParams ProtectedpathsRemoveStreamRequest) ProtectedpathsAPIProtectedpathsRemoveStreamRequest {
	r.protectedPathRemoveStreamParams = &protectedPathRemoveStreamParams
	return r
}

func (r ProtectedpathsAPIProtectedpathsRemoveStreamRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProtectedpathsRemoveStreamExecute(r)
}

/*
ProtectedpathsRemoveStream Remove a Stream from the group connected to this Protected Path

This endpoint removes a replication stream from current protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsRemoveStreamRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsRemoveStream(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsRemoveStreamRequest {
	return ProtectedpathsAPIProtectedpathsRemoveStreamRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProtectedpathsAPIService) ProtectedpathsRemoveStreamExecute(r ProtectedpathsAPIProtectedpathsRemoveStreamRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsRemoveStream")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/remove_stream/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectedPathRemoveStreamParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsRestoreRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
	protectedPathRestoreParams *ProtectedpathsRestoreRequest
}

func (r ProtectedpathsAPIProtectedpathsRestoreRequest) ProtectedPathRestoreParams(protectedPathRestoreParams ProtectedpathsRestoreRequest) ProtectedpathsAPIProtectedpathsRestoreRequest {
	r.protectedPathRestoreParams = &protectedPathRestoreParams
	return r
}

func (r ProtectedpathsAPIProtectedpathsRestoreRequest) Execute() (*AsyncGlobalSnapStream, *http.Response, error) {
	return r.ApiService.ProtectedpathsRestoreExecute(r)
}

/*
ProtectedpathsRestore Restores selected snapshot on protected path.

This endpoint restores selected snapshot on protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsRestoreRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsRestore(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsRestoreRequest {
	return ProtectedpathsAPIProtectedpathsRestoreRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AsyncGlobalSnapStream
func (a *ProtectedpathsAPIService) ProtectedpathsRestoreExecute(r ProtectedpathsAPIProtectedpathsRestoreRequest) (*AsyncGlobalSnapStream, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncGlobalSnapStream
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsRestore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectedPathRestoreParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsResumeRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
	protectedPathResumeParams *ProtectedpathsResumeRequest
}

func (r ProtectedpathsAPIProtectedpathsResumeRequest) ProtectedPathResumeParams(protectedPathResumeParams ProtectedpathsResumeRequest) ProtectedpathsAPIProtectedpathsResumeRequest {
	r.protectedPathResumeParams = &protectedPathResumeParams
	return r
}

func (r ProtectedpathsAPIProtectedpathsResumeRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProtectedpathsResumeExecute(r)
}

/*
ProtectedpathsResume Resume snapshot restore on protected path.

This endpoint resumes snapshot restore on protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsResumeRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsResume(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsResumeRequest {
	return ProtectedpathsAPIProtectedpathsResumeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProtectedpathsAPIService) ProtectedpathsResumeExecute(r ProtectedpathsAPIProtectedpathsResumeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsResume")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.protectedPathResumeParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsStopRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
}

func (r ProtectedpathsAPIProtectedpathsStopRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProtectedpathsStopExecute(r)
}

/*
ProtectedpathsStop Stops snapshot restore on protected path.

This endpoint stops snapshot restore on protected path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsStopRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsStop(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsStopRequest {
	return ProtectedpathsAPIProtectedpathsStopRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProtectedpathsAPIService) ProtectedpathsStopExecute(r ProtectedpathsAPIProtectedpathsStopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsStop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ProtectedpathsAPIProtectedpathsValidateRequest struct {
	ctx context.Context
	ApiService *ProtectedpathsAPIService
	id string
}

func (r ProtectedpathsAPIProtectedpathsValidateRequest) Execute() (*ProtectedpathsValidate200Response, *http.Response, error) {
	return r.ApiService.ProtectedpathsValidateExecute(r)
}

/*
ProtectedpathsValidate Returns validations results for Protected Path.

This endpoint returns validations results for Protected Path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ProtectedpathsAPIProtectedpathsValidateRequest
*/
func (a *ProtectedpathsAPIService) ProtectedpathsValidate(ctx context.Context, id string) ProtectedpathsAPIProtectedpathsValidateRequest {
	return ProtectedpathsAPIProtectedpathsValidateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProtectedpathsValidate200Response
func (a *ProtectedpathsAPIService) ProtectedpathsValidateExecute(r ProtectedpathsAPIProtectedpathsValidateRequest) (*ProtectedpathsValidate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectedpathsValidate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectedpathsAPIService.ProtectedpathsValidate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/protectedpaths/{id}/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
