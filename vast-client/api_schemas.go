/*
VAST API Swagger Schema

VAST Management API definition

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SchemasAPIService SchemasAPI service
type SchemasAPIService service

type SchemasAPISchemasCreateRequest struct {
	ctx context.Context
	ApiService *SchemasAPIService
	schemaCreateParamsBody *SchemaCreateParams
}

func (r SchemasAPISchemasCreateRequest) SchemaCreateParamsBody(schemaCreateParamsBody SchemaCreateParams) SchemasAPISchemasCreateRequest {
	r.schemaCreateParamsBody = &schemaCreateParamsBody
	return r
}

func (r SchemasAPISchemasCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.SchemasCreateExecute(r)
}

/*
SchemasCreate Create a Database Schema

This endpoint creates a Database Schema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SchemasAPISchemasCreateRequest
*/
func (a *SchemasAPIService) SchemasCreate(ctx context.Context) SchemasAPISchemasCreateRequest {
	return SchemasAPISchemasCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SchemasAPIService) SchemasCreateExecute(r SchemasAPISchemasCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasAPIService.SchemasCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/schemas/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schemaCreateParamsBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SchemasAPISchemasDeleteRequest struct {
	ctx context.Context
	ApiService *SchemasAPIService
	schemaDeleteParamsBody *SchemaDeleteParams
}

func (r SchemasAPISchemasDeleteRequest) SchemaDeleteParamsBody(schemaDeleteParamsBody SchemaDeleteParams) SchemasAPISchemasDeleteRequest {
	r.schemaDeleteParamsBody = &schemaDeleteParamsBody
	return r
}

func (r SchemasAPISchemasDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SchemasDeleteExecute(r)
}

/*
SchemasDelete Delete a Database Schema

This endpoint deletes a Database Schema.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SchemasAPISchemasDeleteRequest
*/
func (a *SchemasAPIService) SchemasDelete(ctx context.Context) SchemasAPISchemasDeleteRequest {
	return SchemasAPISchemasDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SchemasAPIService) SchemasDeleteExecute(r SchemasAPISchemasDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasAPIService.SchemasDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/schemas/delete/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schemaDeleteParamsBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SchemasAPISchemasListRequest struct {
	ctx context.Context
	ApiService *SchemasAPIService
	page *int32
	pageSize *int32
	databaseName *string
	schemaName *string
	name *string
	nameStartswith *string
	countOnly *bool
	schemaNameStartswith *string
	byLevel *string
}

func (r SchemasAPISchemasListRequest) Page(page int32) SchemasAPISchemasListRequest {
	r.page = &page
	return r
}

func (r SchemasAPISchemasListRequest) PageSize(pageSize int32) SchemasAPISchemasListRequest {
	r.pageSize = &pageSize
	return r
}

// Getting list of objects by database_name
func (r SchemasAPISchemasListRequest) DatabaseName(databaseName string) SchemasAPISchemasListRequest {
	r.databaseName = &databaseName
	return r
}

// Getting list of objects by schema_name
func (r SchemasAPISchemasListRequest) SchemaName(schemaName string) SchemasAPISchemasListRequest {
	r.schemaName = &schemaName
	return r
}

// Getting list of objects by exact match
func (r SchemasAPISchemasListRequest) Name(name string) SchemasAPISchemasListRequest {
	r.name = &name
	return r
}

// Getting list of objects by prefix match
func (r SchemasAPISchemasListRequest) NameStartswith(nameStartswith string) SchemasAPISchemasListRequest {
	r.nameStartswith = &nameStartswith
	return r
}

// Whether to only return count of objects
func (r SchemasAPISchemasListRequest) CountOnly(countOnly bool) SchemasAPISchemasListRequest {
	r.countOnly = &countOnly
	return r
}

// Getting list of objects starting with by schema_name__startswith (deprecated since 5.0)
func (r SchemasAPISchemasListRequest) SchemaNameStartswith(schemaNameStartswith string) SchemasAPISchemasListRequest {
	r.schemaNameStartswith = &schemaNameStartswith
	return r
}

// Can be true or false. If this by_level is true, the VMS will provide a list of all schemas of only one level. to get the next level, need to make another request with the name of the parent scheme 
func (r SchemasAPISchemasListRequest) ByLevel(byLevel string) SchemasAPISchemasListRequest {
	r.byLevel = &byLevel
	return r
}

func (r SchemasAPISchemasListRequest) Execute() ([]Schema, *http.Response, error) {
	return r.ApiService.SchemasListExecute(r)
}

/*
SchemasList List Database Schemas

This endpoint lists Database Schemas.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SchemasAPISchemasListRequest
*/
func (a *SchemasAPIService) SchemasList(ctx context.Context) SchemasAPISchemasListRequest {
	return SchemasAPISchemasListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Schema
func (a *SchemasAPIService) SchemasListExecute(r SchemasAPISchemasListRequest) ([]Schema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Schema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasAPIService.SchemasList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/schemas/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
	} else {
		var defaultValue int32 = 999
		r.pageSize = &defaultValue
	}
	if r.databaseName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "database_name", r.databaseName, "")
	}
	if r.schemaName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "schema_name", r.schemaName, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameStartswith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name__startswith", r.nameStartswith, "")
	}
	if r.countOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count_only", r.countOnly, "")
	} else {
		var defaultValue bool = false
		r.countOnly = &defaultValue
	}
	if r.schemaNameStartswith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "schema_name__startswith", r.schemaNameStartswith, "")
	}
	if r.byLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "by_level", r.byLevel, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SchemasAPISchemasRenameRequest struct {
	ctx context.Context
	ApiService *SchemasAPIService
	schemaRenameParamsBody *SchemaRenameParams
}

func (r SchemasAPISchemasRenameRequest) SchemaRenameParamsBody(schemaRenameParamsBody SchemaRenameParams) SchemasAPISchemasRenameRequest {
	r.schemaRenameParamsBody = &schemaRenameParamsBody
	return r
}

func (r SchemasAPISchemasRenameRequest) Execute() (*http.Response, error) {
	return r.ApiService.SchemasRenameExecute(r)
}

/*
SchemasRename Rename a Database Schema

This endpoint renames a Database Schema.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SchemasAPISchemasRenameRequest
*/
func (a *SchemasAPIService) SchemasRename(ctx context.Context) SchemasAPISchemasRenameRequest {
	return SchemasAPISchemasRenameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SchemasAPIService) SchemasRenameExecute(r SchemasAPISchemasRenameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasAPIService.SchemasRename")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/schemas/rename/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schemaRenameParamsBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type SchemasAPISchemasShowRequest struct {
	ctx context.Context
	ApiService *SchemasAPIService
	databaseName *string
	name *string
}

// Getting list of objects by database_name
func (r SchemasAPISchemasShowRequest) DatabaseName(databaseName string) SchemasAPISchemasShowRequest {
	r.databaseName = &databaseName
	return r
}

// Getting object by exact match
func (r SchemasAPISchemasShowRequest) Name(name string) SchemasAPISchemasShowRequest {
	r.name = &name
	return r
}

func (r SchemasAPISchemasShowRequest) Execute() (*Schema, *http.Response, error) {
	return r.ApiService.SchemasShowExecute(r)
}

/*
SchemasShow Show a Database Schema

This endpoint shows a Database Schema.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SchemasAPISchemasShowRequest
*/
func (a *SchemasAPIService) SchemasShow(ctx context.Context) SchemasAPISchemasShowRequest {
	return SchemasAPISchemasShowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Schema
func (a *SchemasAPIService) SchemasShowExecute(r SchemasAPISchemasShowRequest) (*Schema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Schema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SchemasAPIService.SchemasShow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/schemas/show/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.databaseName == nil {
		return localVarReturnValue, nil, reportError("databaseName is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "database_name", r.databaseName, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
