/*
VAST API Swagger Schema

VAST Management API definition

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// VastcatalogconfigAPIService VastcatalogconfigAPI service
type VastcatalogconfigAPIService service

type VastcatalogconfigAPIVastcatalogconfigColumnsRequest struct {
	ctx context.Context
	ApiService *VastcatalogconfigAPIService
}

func (r VastcatalogconfigAPIVastcatalogconfigColumnsRequest) Execute() ([]Column, *http.Response, error) {
	return r.ApiService.VastcatalogconfigColumnsExecute(r)
}

/*
VastcatalogconfigColumns Receives Vast Catalog columns

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VastcatalogconfigAPIVastcatalogconfigColumnsRequest
*/
func (a *VastcatalogconfigAPIService) VastcatalogconfigColumns(ctx context.Context) VastcatalogconfigAPIVastcatalogconfigColumnsRequest {
	return VastcatalogconfigAPIVastcatalogconfigColumnsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Column
func (a *VastcatalogconfigAPIService) VastcatalogconfigColumnsExecute(r VastcatalogconfigAPIVastcatalogconfigColumnsRequest) ([]Column, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Column
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VastcatalogconfigAPIService.VastcatalogconfigColumns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bigcatalogconfig/columns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VastcatalogconfigAPIVastcatalogconfigCreateRequest struct {
	ctx context.Context
	ApiService *VastcatalogconfigAPIService
	vastCatalogConfigCreateParams *VastcatalogconfigCreateRequest
}

func (r VastcatalogconfigAPIVastcatalogconfigCreateRequest) VastCatalogConfigCreateParams(vastCatalogConfigCreateParams VastcatalogconfigCreateRequest) VastcatalogconfigAPIVastcatalogconfigCreateRequest {
	r.vastCatalogConfigCreateParams = &vastCatalogConfigCreateParams
	return r
}

func (r VastcatalogconfigAPIVastcatalogconfigCreateRequest) Execute() (*VastCatalogConfig, *http.Response, error) {
	return r.ApiService.VastcatalogconfigCreateExecute(r)
}

/*
VastcatalogconfigCreate Create a Vast DB Config

This endpoint creates a Vast Catalog Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VastcatalogconfigAPIVastcatalogconfigCreateRequest
*/
func (a *VastcatalogconfigAPIService) VastcatalogconfigCreate(ctx context.Context) VastcatalogconfigAPIVastcatalogconfigCreateRequest {
	return VastcatalogconfigAPIVastcatalogconfigCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VastCatalogConfig
func (a *VastcatalogconfigAPIService) VastcatalogconfigCreateExecute(r VastcatalogconfigAPIVastcatalogconfigCreateRequest) (*VastCatalogConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VastCatalogConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VastcatalogconfigAPIService.VastcatalogconfigCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bigcatalogconfig/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vastCatalogConfigCreateParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VastcatalogconfigAPIVastcatalogconfigDeleteRequest struct {
	ctx context.Context
	ApiService *VastcatalogconfigAPIService
	id string
}

func (r VastcatalogconfigAPIVastcatalogconfigDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VastcatalogconfigDeleteExecute(r)
}

/*
VastcatalogconfigDelete Delete Vast Catalog Config and Vast Catalog Policy.

This endpoint deletes Vast Catalog Config.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Vastcatalogconfig ID
 @return VastcatalogconfigAPIVastcatalogconfigDeleteRequest
*/
func (a *VastcatalogconfigAPIService) VastcatalogconfigDelete(ctx context.Context, id string) VastcatalogconfigAPIVastcatalogconfigDeleteRequest {
	return VastcatalogconfigAPIVastcatalogconfigDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VastcatalogconfigAPIService) VastcatalogconfigDeleteExecute(r VastcatalogconfigAPIVastcatalogconfigDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VastcatalogconfigAPIService.VastcatalogconfigDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bigcatalogconfig/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VastcatalogconfigAPIVastcatalogconfigListRequest struct {
	ctx context.Context
	ApiService *VastcatalogconfigAPIService
	page *int32
	pageSize *int32
}

func (r VastcatalogconfigAPIVastcatalogconfigListRequest) Page(page int32) VastcatalogconfigAPIVastcatalogconfigListRequest {
	r.page = &page
	return r
}

func (r VastcatalogconfigAPIVastcatalogconfigListRequest) PageSize(pageSize int32) VastcatalogconfigAPIVastcatalogconfigListRequest {
	r.pageSize = &pageSize
	return r
}

func (r VastcatalogconfigAPIVastcatalogconfigListRequest) Execute() ([]VastCatalogConfig, *http.Response, error) {
	return r.ApiService.VastcatalogconfigListExecute(r)
}

/*
VastcatalogconfigList List of Vast Catalog Config

This endpoint returns list of Vast Catalog Config.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VastcatalogconfigAPIVastcatalogconfigListRequest
*/
func (a *VastcatalogconfigAPIService) VastcatalogconfigList(ctx context.Context) VastcatalogconfigAPIVastcatalogconfigListRequest {
	return VastcatalogconfigAPIVastcatalogconfigListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VastCatalogConfig
func (a *VastcatalogconfigAPIService) VastcatalogconfigListExecute(r VastcatalogconfigAPIVastcatalogconfigListRequest) ([]VastCatalogConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VastCatalogConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VastcatalogconfigAPIService.VastcatalogconfigList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bigcatalogconfig/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VastcatalogconfigAPIVastcatalogconfigModifyRequest struct {
	ctx context.Context
	ApiService *VastcatalogconfigAPIService
	id string
	vastCatalogConfigModifyParams *VastcatalogconfigModifyRequest
}

func (r VastcatalogconfigAPIVastcatalogconfigModifyRequest) VastCatalogConfigModifyParams(vastCatalogConfigModifyParams VastcatalogconfigModifyRequest) VastcatalogconfigAPIVastcatalogconfigModifyRequest {
	r.vastCatalogConfigModifyParams = &vastCatalogConfigModifyParams
	return r
}

func (r VastcatalogconfigAPIVastcatalogconfigModifyRequest) Execute() (*http.Response, error) {
	return r.ApiService.VastcatalogconfigModifyExecute(r)
}

/*
VastcatalogconfigModify Modify Vast Catalog Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Vast Catalog Config Policy ID
 @return VastcatalogconfigAPIVastcatalogconfigModifyRequest
*/
func (a *VastcatalogconfigAPIService) VastcatalogconfigModify(ctx context.Context, id string) VastcatalogconfigAPIVastcatalogconfigModifyRequest {
	return VastcatalogconfigAPIVastcatalogconfigModifyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *VastcatalogconfigAPIService) VastcatalogconfigModifyExecute(r VastcatalogconfigAPIVastcatalogconfigModifyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VastcatalogconfigAPIService.VastcatalogconfigModify")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bigcatalogconfig/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vastCatalogConfigModifyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type VastcatalogconfigAPIVastcatalogconfigQueryDataRequest struct {
	ctx context.Context
	ApiService *VastcatalogconfigAPIService
	page *int32
	limit *int32
	vastCatalogConfigQueryData *VastCatalogQueryDataInputSchema
}

func (r VastcatalogconfigAPIVastcatalogconfigQueryDataRequest) Page(page int32) VastcatalogconfigAPIVastcatalogconfigQueryDataRequest {
	r.page = &page
	return r
}

func (r VastcatalogconfigAPIVastcatalogconfigQueryDataRequest) Limit(limit int32) VastcatalogconfigAPIVastcatalogconfigQueryDataRequest {
	r.limit = &limit
	return r
}

func (r VastcatalogconfigAPIVastcatalogconfigQueryDataRequest) VastCatalogConfigQueryData(vastCatalogConfigQueryData VastCatalogQueryDataInputSchema) VastcatalogconfigAPIVastcatalogconfigQueryDataRequest {
	r.vastCatalogConfigQueryData = &vastCatalogConfigQueryData
	return r
}

func (r VastcatalogconfigAPIVastcatalogconfigQueryDataRequest) Execute() (*QueryDataOutputSchema, *http.Response, error) {
	return r.ApiService.VastcatalogconfigQueryDataExecute(r)
}

/*
VastcatalogconfigQueryData Receives information according to the sent rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VastcatalogconfigAPIVastcatalogconfigQueryDataRequest
*/
func (a *VastcatalogconfigAPIService) VastcatalogconfigQueryData(ctx context.Context) VastcatalogconfigAPIVastcatalogconfigQueryDataRequest {
	return VastcatalogconfigAPIVastcatalogconfigQueryDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryDataOutputSchema
func (a *VastcatalogconfigAPIService) VastcatalogconfigQueryDataExecute(r VastcatalogconfigAPIVastcatalogconfigQueryDataRequest) (*QueryDataOutputSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryDataOutputSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VastcatalogconfigAPIService.VastcatalogconfigQueryData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bigcatalogconfig/query_data/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 1000
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vastCatalogConfigQueryData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VastcatalogconfigAPIVastcatalogconfigReadRequest struct {
	ctx context.Context
	ApiService *VastcatalogconfigAPIService
	id string
}

func (r VastcatalogconfigAPIVastcatalogconfigReadRequest) Execute() (*VastCatalogConfig, *http.Response, error) {
	return r.ApiService.VastcatalogconfigReadExecute(r)
}

/*
VastcatalogconfigRead Return Vast Catalog Config

This endpoint returns Vast Catalog Config details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Vastcatalogconfig ID
 @return VastcatalogconfigAPIVastcatalogconfigReadRequest
*/
func (a *VastcatalogconfigAPIService) VastcatalogconfigRead(ctx context.Context, id string) VastcatalogconfigAPIVastcatalogconfigReadRequest {
	return VastcatalogconfigAPIVastcatalogconfigReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VastCatalogConfig
func (a *VastcatalogconfigAPIService) VastcatalogconfigReadExecute(r VastcatalogconfigAPIVastcatalogconfigReadRequest) (*VastCatalogConfig, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VastCatalogConfig
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VastcatalogconfigAPIService.VastcatalogconfigRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bigcatalogconfig/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type VastcatalogconfigAPIVastcatalogconfigStatsRequest struct {
	ctx context.Context
	ApiService *VastcatalogconfigAPIService
}

func (r VastcatalogconfigAPIVastcatalogconfigStatsRequest) Execute() (*Stats, *http.Response, error) {
	return r.ApiService.VastcatalogconfigStatsExecute(r)
}

/*
VastcatalogconfigStats Receives information about Vast Catalog stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return VastcatalogconfigAPIVastcatalogconfigStatsRequest
*/
func (a *VastcatalogconfigAPIService) VastcatalogconfigStats(ctx context.Context) VastcatalogconfigAPIVastcatalogconfigStatsRequest {
	return VastcatalogconfigAPIVastcatalogconfigStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Stats
func (a *VastcatalogconfigAPIService) VastcatalogconfigStatsExecute(r VastcatalogconfigAPIVastcatalogconfigStatsRequest) (*Stats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VastcatalogconfigAPIService.VastcatalogconfigStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bigcatalogconfig/stats/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
