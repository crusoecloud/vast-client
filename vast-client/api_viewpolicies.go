/*
VAST API Swagger Schema

VAST Management API definition

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ViewpoliciesAPIService ViewpoliciesAPI service
type ViewpoliciesAPIService service

type ViewpoliciesAPIAddRemoteMappingRequest struct {
	ctx context.Context
	ApiService *ViewpoliciesAPIService
	id string
	addRemoteMappingParams *AddRemoteMappingRequest
}

func (r ViewpoliciesAPIAddRemoteMappingRequest) AddRemoteMappingParams(addRemoteMappingParams AddRemoteMappingRequest) ViewpoliciesAPIAddRemoteMappingRequest {
	r.addRemoteMappingParams = &addRemoteMappingParams
	return r
}

func (r ViewpoliciesAPIAddRemoteMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddRemoteMappingExecute(r)
}

/*
AddRemoteMapping Method for AddRemoteMapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ViewpoliciesAPIAddRemoteMappingRequest
*/
func (a *ViewpoliciesAPIService) AddRemoteMapping(ctx context.Context, id string) ViewpoliciesAPIAddRemoteMappingRequest {
	return ViewpoliciesAPIAddRemoteMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ViewpoliciesAPIService) AddRemoteMappingExecute(r ViewpoliciesAPIAddRemoteMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewpoliciesAPIService.AddRemoteMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/viewpolicies/{id}/remote_mapping/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addRemoteMappingParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ViewpoliciesAPIRefreshNetgroupsRequest struct {
	ctx context.Context
	ApiService *ViewpoliciesAPIService
	id string
}

func (r ViewpoliciesAPIRefreshNetgroupsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RefreshNetgroupsExecute(r)
}

/*
RefreshNetgroups refresh View policy netgroups

refresh View policy netgroups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ViewpoliciesAPIRefreshNetgroupsRequest
*/
func (a *ViewpoliciesAPIService) RefreshNetgroups(ctx context.Context, id string) ViewpoliciesAPIRefreshNetgroupsRequest {
	return ViewpoliciesAPIRefreshNetgroupsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ViewpoliciesAPIService) RefreshNetgroupsExecute(r ViewpoliciesAPIRefreshNetgroupsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewpoliciesAPIService.RefreshNetgroups")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/viewpolicies/{id}/refresh_netgroups/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ViewpoliciesAPIRemoveRemoteMappingRequest struct {
	ctx context.Context
	ApiService *ViewpoliciesAPIService
	id string
	removeRemoteMappingParams *RemoveRemoteMappingRequest
}

func (r ViewpoliciesAPIRemoveRemoteMappingRequest) RemoveRemoteMappingParams(removeRemoteMappingParams RemoveRemoteMappingRequest) ViewpoliciesAPIRemoveRemoteMappingRequest {
	r.removeRemoteMappingParams = &removeRemoteMappingParams
	return r
}

func (r ViewpoliciesAPIRemoveRemoteMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveRemoteMappingExecute(r)
}

/*
RemoveRemoteMapping Method for RemoveRemoteMapping

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ViewpoliciesAPIRemoveRemoteMappingRequest
*/
func (a *ViewpoliciesAPIService) RemoveRemoteMapping(ctx context.Context, id string) ViewpoliciesAPIRemoveRemoteMappingRequest {
	return ViewpoliciesAPIRemoveRemoteMappingRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ViewpoliciesAPIService) RemoveRemoteMappingExecute(r ViewpoliciesAPIRemoveRemoteMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewpoliciesAPIService.RemoveRemoteMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/viewpolicies/{id}/remote_mapping/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeRemoteMappingParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ViewpoliciesAPIViewpoliciesCreateRequest struct {
	ctx context.Context
	ApiService *ViewpoliciesAPIService
	viewpolicyCreateParams *ViewpoliciesCreateRequest
}

func (r ViewpoliciesAPIViewpoliciesCreateRequest) ViewpolicyCreateParams(viewpolicyCreateParams ViewpoliciesCreateRequest) ViewpoliciesAPIViewpoliciesCreateRequest {
	r.viewpolicyCreateParams = &viewpolicyCreateParams
	return r
}

func (r ViewpoliciesAPIViewpoliciesCreateRequest) Execute() (*ViewPolicy, *http.Response, error) {
	return r.ApiService.ViewpoliciesCreateExecute(r)
}

/*
ViewpoliciesCreate Create View Policy

This endpoint creates a view policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ViewpoliciesAPIViewpoliciesCreateRequest
*/
func (a *ViewpoliciesAPIService) ViewpoliciesCreate(ctx context.Context) ViewpoliciesAPIViewpoliciesCreateRequest {
	return ViewpoliciesAPIViewpoliciesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewPolicy
func (a *ViewpoliciesAPIService) ViewpoliciesCreateExecute(r ViewpoliciesAPIViewpoliciesCreateRequest) (*ViewPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewpoliciesAPIService.ViewpoliciesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/viewpolicies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.viewpolicyCreateParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ViewpoliciesAPIViewpoliciesDeleteRequest struct {
	ctx context.Context
	ApiService *ViewpoliciesAPIService
	id string
}

func (r ViewpoliciesAPIViewpoliciesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ViewpoliciesDeleteExecute(r)
}

/*
ViewpoliciesDelete Delete View Policy.

This endpoint deletes a view policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the view policy to delete
 @return ViewpoliciesAPIViewpoliciesDeleteRequest
*/
func (a *ViewpoliciesAPIService) ViewpoliciesDelete(ctx context.Context, id string) ViewpoliciesAPIViewpoliciesDeleteRequest {
	return ViewpoliciesAPIViewpoliciesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ViewpoliciesAPIService) ViewpoliciesDeleteExecute(r ViewpoliciesAPIViewpoliciesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewpoliciesAPIService.ViewpoliciesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/viewpolicies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ViewpoliciesAPIViewpoliciesListRequest struct {
	ctx context.Context
	ApiService *ViewpoliciesAPIService
	atimeFrequency *string
	page *string
	name *string
	clusterName *string
	clusterId *string
	nfsReturnOpenPermissions *bool
	smbFileMode *int32
	smbDirectoryMode *int32
	appleSid *bool
	tenantId *int32
	tenantNameIcontains *string
	servesTenant *string
}

// Filter by atime frequency.
func (r ViewpoliciesAPIViewpoliciesListRequest) AtimeFrequency(atimeFrequency string) ViewpoliciesAPIViewpoliciesListRequest {
	r.atimeFrequency = &atimeFrequency
	return r
}

func (r ViewpoliciesAPIViewpoliciesListRequest) Page(page string) ViewpoliciesAPIViewpoliciesListRequest {
	r.page = &page
	return r
}

// Filter by name.
func (r ViewpoliciesAPIViewpoliciesListRequest) Name(name string) ViewpoliciesAPIViewpoliciesListRequest {
	r.name = &name
	return r
}

func (r ViewpoliciesAPIViewpoliciesListRequest) ClusterName(clusterName string) ViewpoliciesAPIViewpoliciesListRequest {
	r.clusterName = &clusterName
	return r
}

func (r ViewpoliciesAPIViewpoliciesListRequest) ClusterId(clusterId string) ViewpoliciesAPIViewpoliciesListRequest {
	r.clusterId = &clusterId
	return r
}

// Filter by enabled nfs-return-open-permissions flag
func (r ViewpoliciesAPIViewpoliciesListRequest) NfsReturnOpenPermissions(nfsReturnOpenPermissions bool) ViewpoliciesAPIViewpoliciesListRequest {
	r.nfsReturnOpenPermissions = &nfsReturnOpenPermissions
	return r
}

// Filter by smb_file_mode. smb_file_mode is the default unix permission bits applied to files created by SMB clients. It is relevant only to views that are exposed to both SMB and NFS access protocols and have NFS security flavor.
func (r ViewpoliciesAPIViewpoliciesListRequest) SmbFileMode(smbFileMode int32) ViewpoliciesAPIViewpoliciesListRequest {
	r.smbFileMode = &smbFileMode
	return r
}

// Filter by smb_directory_mode. smb_directory_mode is the default unix permission bits applied to directories created by SMB clients. It is relevant only to views that are exposed to both SMB and NFS access protocols and have NFS security flavor.
func (r ViewpoliciesAPIViewpoliciesListRequest) SmbDirectoryMode(smbDirectoryMode int32) ViewpoliciesAPIViewpoliciesListRequest {
	r.smbDirectoryMode = &smbDirectoryMode
	return r
}

// apple sid
func (r ViewpoliciesAPIViewpoliciesListRequest) AppleSid(appleSid bool) ViewpoliciesAPIViewpoliciesListRequest {
	r.appleSid = &appleSid
	return r
}

// Tenant id to filter by.
func (r ViewpoliciesAPIViewpoliciesListRequest) TenantId(tenantId int32) ViewpoliciesAPIViewpoliciesListRequest {
	r.tenantId = &tenantId
	return r
}

// Tenant name to filter by
func (r ViewpoliciesAPIViewpoliciesListRequest) TenantNameIcontains(tenantNameIcontains string) ViewpoliciesAPIViewpoliciesListRequest {
	r.tenantNameIcontains = &tenantNameIcontains
	return r
}

// Filter by served tenants. Accepts Tenant ID or \&quot;all\&quot;.
func (r ViewpoliciesAPIViewpoliciesListRequest) ServesTenant(servesTenant string) ViewpoliciesAPIViewpoliciesListRequest {
	r.servesTenant = &servesTenant
	return r
}

func (r ViewpoliciesAPIViewpoliciesListRequest) Execute() ([]ViewPolicy, *http.Response, error) {
	return r.ApiService.ViewpoliciesListExecute(r)
}

/*
ViewpoliciesList List View Policies

This endpoint lists view policies.<p>By default, all view policies are returned. The list can be filtered using optional parameters. A view policy is a reusable set of configurations that apply to views. Every view has a view policy. A view policy may be used by multiple views.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ViewpoliciesAPIViewpoliciesListRequest
*/
func (a *ViewpoliciesAPIService) ViewpoliciesList(ctx context.Context) ViewpoliciesAPIViewpoliciesListRequest {
	return ViewpoliciesAPIViewpoliciesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ViewPolicy
func (a *ViewpoliciesAPIService) ViewpoliciesListExecute(r ViewpoliciesAPIViewpoliciesListRequest) ([]ViewPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ViewPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewpoliciesAPIService.ViewpoliciesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/viewpolicies/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.atimeFrequency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "atime_frequency", r.atimeFrequency, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.clusterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster__name", r.clusterName, "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster__id", r.clusterId, "")
	}
	if r.nfsReturnOpenPermissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nfs_return_open_permissions", r.nfsReturnOpenPermissions, "")
	}
	if r.smbFileMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smb_file_mode", r.smbFileMode, "")
	}
	if r.smbDirectoryMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smb_directory_mode", r.smbDirectoryMode, "")
	}
	if r.appleSid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apple_sid", r.appleSid, "")
	}
	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_id", r.tenantId, "")
	}
	if r.tenantNameIcontains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant_name__icontains", r.tenantNameIcontains, "")
	}
	if r.servesTenant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serves_tenant", r.servesTenant, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ViewpoliciesAPIViewpoliciesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *ViewpoliciesAPIService
	id string
	viewpolicyModifyParams *ViewpoliciesPartialUpdateRequest
}

func (r ViewpoliciesAPIViewpoliciesPartialUpdateRequest) ViewpolicyModifyParams(viewpolicyModifyParams ViewpoliciesPartialUpdateRequest) ViewpoliciesAPIViewpoliciesPartialUpdateRequest {
	r.viewpolicyModifyParams = &viewpolicyModifyParams
	return r
}

func (r ViewpoliciesAPIViewpoliciesPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.ViewpoliciesPartialUpdateExecute(r)
}

/*
ViewpoliciesPartialUpdate Modify a View Policy

Modify a view policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ViewpoliciesAPIViewpoliciesPartialUpdateRequest
*/
func (a *ViewpoliciesAPIService) ViewpoliciesPartialUpdate(ctx context.Context, id string) ViewpoliciesAPIViewpoliciesPartialUpdateRequest {
	return ViewpoliciesAPIViewpoliciesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ViewpoliciesAPIService) ViewpoliciesPartialUpdateExecute(r ViewpoliciesAPIViewpoliciesPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewpoliciesAPIService.ViewpoliciesPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/viewpolicies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.viewpolicyModifyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ViewpoliciesAPIViewpoliciesReadRequest struct {
	ctx context.Context
	ApiService *ViewpoliciesAPIService
	id string
}

func (r ViewpoliciesAPIViewpoliciesReadRequest) Execute() (*ViewPolicy, *http.Response, error) {
	return r.ApiService.ViewpoliciesReadExecute(r)
}

/*
ViewpoliciesRead Return Details of a View Policy

This endpoint returns a specified view policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the view policy
 @return ViewpoliciesAPIViewpoliciesReadRequest
*/
func (a *ViewpoliciesAPIService) ViewpoliciesRead(ctx context.Context, id string) ViewpoliciesAPIViewpoliciesReadRequest {
	return ViewpoliciesAPIViewpoliciesReadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ViewPolicy
func (a *ViewpoliciesAPIService) ViewpoliciesReadExecute(r ViewpoliciesAPIViewpoliciesReadRequest) (*ViewPolicy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewPolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewpoliciesAPIService.ViewpoliciesRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/viewpolicies/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
